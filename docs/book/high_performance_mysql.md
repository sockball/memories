* mysql逻辑架构
    * 连接/线程处理：连接处理、授权认证、安全等等
    * mysql服务器层：查询解析、分析、优化、缓存以及所有的内置函数、存储过程、视图等等
    * 存储引擎层：负责mysql中数据的存储和提取

* 2种锁策略：表锁；行级锁

* 行级锁只在存储引擎层实现，而mysql服务器层没有实现

* 事务的ACID特征
    * 原子性（atomicity）  ：一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚
    * 一致性（consistency）：只要事务最终未提交，事务中的修改就不会被保存到数据库
    * 隔离性（isolation）  ：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的
    * 持久性（durability） ：一旦事务提交，其所做的修改会永久保存到数据库中

* 事务的隔离级别
    * `READ UNCOMMITTED`（未提交读）：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也称为脏读（Dirty Read）
    * `READ COMMITTED`（提交读）：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，也称为不可重复读（nonrepeatable read）
    * `REPEATABLE READ`（可重复读）：mysql的默认事务隔离级别。同一个事务中多次读取同样记录的结果是一致的
    * `SERIALIZABLE`（可串行化）：强制事务串行执行，在每一行数据上都加锁，可能导致大量的超时和锁竞争的问题
    * 可通过以下命令设置隔离级别
        ```sql
        SET TRANSACTION ISOLATION LEVEL [READ COMMITTED]
        ```

* 死锁：指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象

* 自动提交：mysql默认采用自动提交（autocommit）模式。如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。

* 事务型存储引擎的多版本并发控制（MVCC），可以认为是行级锁的变种，在很多情况下避免了加锁操作，仅在 `REPEATABLE` 和 `READ COMMITTED` 2个隔离级别下工作  

    比如 `InnoDB` 的MVCC是通过在每行记录后保存两个隐藏列：一个保存行的创建时间，一个保存行的过期时间，实际存储的数据为系统版本号。  
    每开始一个新的事务系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号。  
    以下为InnoDB `REPEATABLE READ` 隔离级别下的MVCC具体操作，只有满足条件的记录才能返回作为查询结果
    * `SELECT` 根据两个条件检查每行记录  
    ① 只查找版本早于当前事务版本的数据行，即行的系统版本号小于等于事务的系统版本号  
    ② 行的删除版本号要么未定义，要么大于当前事务版本号
    * `INSERT` 新插入的每一行保存当前系统版本号作为行版本号
    * `DELETE` 删除的每一行保存当前系统版本号作为行删除标识
    * `UPDATE` <strike>插入一行新记录，保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行作为行删除标识</strike><span class='info'>（插入一行新记录?）</span>

* mysql存储引擎
    * `InnoDB`
    * `MyISAM`
    * `Archive`：只支持 INSERT 和 SELECT 操作，每次 SELECT 都需要全表扫描，适合日志和数据采集类应用
    * `BlackHole`：没有实现任何的存储机制，它会丢弃所有的插入数据，不做任何保存，但是服务器会记录BlackHole表的日志，所以可用于复制数据到备库，或者只是简单地记录到日志
    * `CSV`：可将普通的CSV文件作为mysql表处理，但不支持索引。可以作为一种数据交换的机制
    * `Federated`：访问其他mysql服务器的一个代理，它会创建一个到远程mysql服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据
    * `Memory`：数据保存在内存中，重启后表结构还在但数据丢失。支持hash索引，使用表级锁，不支持BLOB或TEXT类型列，且每行长度固定。  
    mysql在查询的过程中需要中间表来保存结果，内部使用的中间表就是memory表。  
    临时表是指使用 `CREATE TEMPORARY TABLE` 创建的表，可以使用任何引擎，要与上述中间表加以区分（一般会称呼中间表为临时表）
    * `Merge`：引入分区功能后舍弃
    * `NDB` 集群引擎

* 在性能测试环境模拟真实的环境，运行应用，然后拔下电源模拟崩溃测试

* 转换表的存储引擎 `ALTER TABLE mytable ENGINE = InnoDB;` 转换后会失去原引擎相关的所有特性

* 同一个数据库中不能存在相同的表名，即使它们使用的是不同的存储引擎

* 通过设置 `long_query_time = 0` 来捕获所有的查询到慢查询日志中  
若长期开启慢查询日志，注意要部署日志轮转（log rotation）工具

* 通常把可为 `NULL` 的列改为 `NOT NULL` 带来的性能提升比较小，所以调优时没有必要首先在现有schema中查找并修改掉这种情况，除非确定会导致问题。  
但是如果计划在列上建立索引，就应该尽量避免设计成可为 `NULL` 的列

* `TINYINT SMALLINT MEDIUMINT INT BIGINT` 分别占用 `8 16 24 32 64` 位存储空间，即 `1 2 3 4 8` 字节（`1byte = 8 bit`），存储范围为 `-2^(N-1)` 到 `2(N-1)-1`，N为存储空间的位数。  
整数类型有可选的 `UNSIGNED` 属性，表示不允许负值。  
有符号和无符号类型占用相同的存储空间，并具有相同的性能。  
可以为整数类型指定宽度，例如 `INT(11)`，规定了显示字符的个数为11。对于存储和计算来说，`INT(1)` 和 `INT(20)` 是相同的
